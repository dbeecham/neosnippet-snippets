# Templates {{{
snippet stdc
options head
	// Try to not define _GNU_SOURCE or _DEFAULT_SOURCE, since those enable
	// glibc-specific features. Being able to compile to e.g. musl or uclibc
	// makes porting to embedded linux systems much easier (and generally
	// pressures the programmer into stricter and better programming practices).
	#define _POSIX_C_SOURCE 201805L

	#include <stdlib.h>
	#include <stdint.h>
	#include <stdbool.h>
	#include <stdio.h>
	#include <unistd.h>
	#include <fcntl.h>
	#include <errno.h>
	#include <string.h>
	#include <syslog.h>
	#include <sys/stat.h>
	#include <sys/epoll.h>
	#include <sys/signalfd.h>
	#include <signal.h>
	#include <pthread.h>
	#include <sys/socket.h>
	#include <netinet/in.h>
	#include <netdb.h>

	#include "`ProjectName()`.h"

	${0}
snippet stdh
options head
	#pragma once

	#include <stdlib.h>
	#include <stdint.h>
	#include <stdbool.h>
	#include <unistd.h>
	#include <fcntl.h>
	#include <errno.h>
	#include <string.h>
	#include <syslog.h>
	#include <sys/stat.h>
	#include <sys/epoll.h>
	#include <sys/signalfd.h>
	#include <signal.h>
	#include <pthread.h>
	#include <sys/socket.h>
	#include <netinet/in.h>
	#include <netdb.h>
# }}}

# Control structures {{{
snippet     if
options     head
abbr        if () {}
    if (${1:-1 == ret}) {
        ${0:TARGET}
    }

snippet     iff
options     head
abbr        if () 
    if (${1:-1 == ret})
        ${0:TARGET}

# No head option in else/elseif so it can be expanded after "}"
snippet     else
abbr        else {}
    else {
        ${0:TARGET}
    }

snippet     elif
abbr        else () {}
    else if (${1:#:condition}) {
        ${0:TARGET}
    }

snippet     for
options     head
abbr        for () {}
    for (${1:int} ${2:i} = ${3:0}; $2 < ${4}; $2++) {
        ${0:#:TARGET}
    }

# Counter based for's (don't ask for the type or count start)
snippet     fori
options     head
abbr        for (int x;...; x++) {}
    for (int ${1:i} = 0; $1 < ${2}; $1++) {
        ${0:#:TARGET}
    }

# For reverse counter
snippet     forri
options     head
abbr        for (int x; ...; x--) {}
    for (int ${1:i} = ${2}; $1 >= 0; $1--) {
        ${0:#:TARGET}
    }

snippet     while
options     head
abbr        while () {}
    while (${1:#:condition}) {
        ${0:TARGET}
    }

snippet     switch
options     head
abbr        switch () {}
	switch (${1:#:var}) {
		case ${2:#:val}:
			${0:TARGET}
			break;
	}

snippet     case
options     head
abbr        case: break;
	case ${1}:
		${0}
		break;

# }}}

# Definition bodies {{{
snippet f
	${1:int} ${2:`ProjectName()`}${3:} (
		${4:struct `ProjectName()`_s * `ProjectName()`}${5:#:,args...}
	)
	{

		int ret = 0;

		${0}

		return 0;
	}

snippet struct
options head
abbr struct {}
	struct ${1:#:name} {
	    uint8_t sentinel;
	    ${0:TARGET:data}
	};

snippet     enum
options     head
abbr        enum {}
    enum ${1:#:name} {
        ${0:TARGET}
    };

# hard-tab is necessary; C indent doesn't support this.
snippet main
options head
	int main (
	    int argc,
	    char const* argv[]
	)
	{
	    ${0:TARGET}
	    return 0;
	}
# }}}

# Preprocessing directives {{{
# #include <...>
snippet     inc
options     head
alias       #inc, #include
    #include <${1:stdio}.h>

# #include "..."
snippet     Inc
options     head
alias       #Inc
    #include "${1}.h"

snippet     ifdef
options     head
alias       #ifdef
abbr        #ifdef ... #endif
    #ifdef ${1:#:SYMBOL}
    ${0}
    #endif

snippet     ifndef
options     head
alias       #ifndef
abbr #ifndef ... #define ... #endif
    #ifndef $1
    #define ${1:#:SYMBOL}
    #endif${0}

# This snippet used the placeholder instead of a trailing space
snippet     def
options     head
alias       #def, #define
    #define ${1}

# }}}

# Built-in function calls {{{
snippet printf
abbr    printf("...\n", ...);
    printf("${1}\n"${2});

snippet scanf
abbr    scanf("...", ...);
    scanf("${1}", ${2});

snippet fprintf
abbr    fprintf(..., "...\n", ...);
    fprintf(${1:stderr}, "${2}\n"${3});

snippet fopen
abbr fopen("...", "...");
	fopen("${1:PATH}", "${2:MODE}");
	${0:TARGET}
	fclose(${3:FD});

snippet fgets
abbr    fgets(row, length, file);
    fgets(${0:ROW}, ${1:LENGTH}, ${2:stdin});

snippet fscanf
abbr    fscanf(file, "...", ...);
    fscanf(${1:stdin}, "${2}", ${3});

snippet fwrite
abbr    fwrite(......, file)
    fwrite(${1:ARRAY}, sizeof(${2:TYPE}), ${3:N_MEMBERS}, ${4:FILE})

snippet fread
abbr    fread(......, file)
    fread(${1:ARRAY}, sizeof(${2:TYPE}), ${3:N_MEMBERS}, ${4:FILE})

snippet memcpy
abbr    memcpy(dest, src, nbytes)
    memcpy(${1:DEST}, ${2:SRC}, ${3:NBYTES})

snippet malloc
abbr    malloc(size)
	($2 *)malloc(${1:N_MEMBERS} * sizeof(${2:TYPE}));
	${0}
	free(${3:MEM});

snippet calloc
abbr    calloc(n, size)
	($2 *)calloc(${1:N_MEMBERS}, sizeof(${2:TYPE}));
	${0}
	free(${3:MEM});

snippet realloc
abbr    realloc(old, size)
	($3 *)realloc(${1:OLD}, ${2:N_MEMBERS} * sizeof(${3:TYPE}));
	${0}

snippet seed_rand
    srand(time(NULL));
# }}}

# Built-in operators and alias {{{
snippet typedef
    typedef ${1:#:base_type} ${2:#:custom_type};

snippet sizeof
alias   size
    sizeof(${0:TARGET})

snippet sizeof_array
alias   array_size
    (sizeof(${1:#:array}) / sizeof(*($1)))

snippet _Static_assert
alias   _static_assert
options head
    _Static_assert(${1:#:condition}, ${2:#:message});

snippet static_assert
options head
    static_assert(${1:#:condition}, ${2:#:message});

snippet _Generic
alias   generic, select
    _Generic(${1:#:expression}, ${2:#:association-list})

snippet va_list
options head
abbr    va_start(va_list, last_arg); ... ; va_end()
	va_list ${1:ap};
	va_start($1, ${2:LAST_ARG});
	${0}
	va_end($1);
# }}}

# syslog {{{
snippet openlog
options head
	openlog("${1:`ProjectName()`}", LOG_CONS | LOG_PID, LOG_USER);
snippet syslog
options head
	// NOTE TO SELF: snippets available for syslog:
	//   * openlog - opens syslog
	//   * err     - syslog() error message
    //   * warn    - syslog() warning message
	//   * info    - syslog() info message
    //   * debug   - syslog() debug message
    //   * hi      - syslog() debug hi message
	// Remember to #include <syslog.h> (snip 'isyslog')
snippet err
options head
	syslog(LOG_ERR, "%s:%d:%s: ${1:msg}", __FILE__, __LINE__, __func__${2:#:, strerror(errno), ...});${0}
snippet warn
options head
	syslog(LOG_WARNING, "%s:%d:%s: ${1:func}: %s", __FILE__, __LINE__, __func__, strerror(errno));${0}
snippet info
options head
	syslog(LOG_INFO, "%s:%d:%s: ${1:#:msg}", __FILE__, __LINE__, __func__${2:#:, args...});${0}
snippet debug
options head
    syslog(LOG_DEBUG, "%s:%d:%s: ${1:#:msg}", __FILE__, __LINE__, __func__${2:#:, args..});${0}
snippet hi
options head
    syslog(LOG_DEBUG, "%s:%d:%s: hi!", __FILE__, __LINE__, __func__);
# }}}

# basic fd stuff {{{
snippet read
    bytes_read = read(${1:fd}, ${2:buf}, ${3:buf_len});
    if (-1 == bytes_read) {
		syslog(LOG_ERR, "%s:%d:%s: read: %s", __FILE__, __LINE__, __func__, strerror(errno));
		return -1;
    }
    if (0 == bytes_read) {
        ${4}
    }
    ${0}
# }}}

# socket {{{
	struct addrinfo *servinfo, *servinfo_p;
	ret = getaddrinfo(
		/* host = */ "${1:127.0.0.1}",
		/* port = */ "${2:4222}",
		/* hints = */ &(struct addrinfo) {
			.ai_family = AF_UNSPEC,
			.ai_socktype = SOCK_STREAM,
			.ai_flags = AI_PASSIVE
		},
		/* servinfo = */ &servinfo
	);
	if (0 != ret) {
		syslog(LOG_ERR, "%s:%d:%s: getaddrinfo: %s", __FILE__, __LINE__, __func__, gai_strerror(ret));
		return -1;
	}

	// Loop over the results from getaddrinfo and try to connect
	for (servinfo_p = servinfo; servinfo_p != NULL; servinfo_p = servinfo_p->ai_next) {
		${3:`ProjectName()`->sock_fd} = socket(servinfo_p->ai_family, servinfo_p->ai_socktype, servinfo_p->ai_protocol);
		if (-1 == $3) {
			syslog(LOG_WARNING, "%s:%d:%s: socket: %s", __FILE__, __LINE__, __func__, strerror(errno));
			continue;
		}

		ret = connect($3, servinfo_p->ai_addr, servinfo_p->ai_addrlen);
		if (-1 == ret) {
			syslog(LOG_WARNING, "%s:%d:%s: connect: %s", __FILE__, __LINE__, __func__, strerror(errno));
			close($3);
			continue;
		}

		break;
	}
	if (NULL == servinfo_p) {
		syslog(LOG_ERR, "%s:%d:%s: failed to connect", __FILE__, __LINE__, __func__);
		return -1;
	}
	freeaddrinfo(servinfo);
	$0
# }}}

# epoll {{{
snippet epoll
options head
	// NOTE TO SELF: snippets available for epoll:
	//   * epc - create epoll
	//   * epa - add fd to epoll
	//   * epd - delete fd from epoll
	//   * epm - modify (re-arm) fd in epoll
	//   * epw - main epoll_wait loop
	// To use epoll, remember to #include <sys/epoll.h> (snip 'iepoll')
snippet epc
	// Create the epoll instance
	${1:`ProjectName()`->epoll_fd} = epoll_create1(EPOLL_CLOEXEC);
	if (-1 == $1) {
		syslog(LOG_ERR, "%s:%d:%s: epoll_create1: %s", __FILE__, __LINE__, __func__, strerror(errno));
		return -1;
	}
    ${0}
snippet epa
	ret = epoll_ctl(
		${1:`vim_snippets#Filename('$1')`->epoll_fd},
		EPOLL_CTL_ADD,
	    ${2:fd},
		&(struct epoll_event){
			.events = EPOLLIN | EPOLLERR | EPOLLHUP | EPOLLONESHOT,
			.data = {
				.fd = $2
			}
		}
	);
	if (-1 == ret) {
		syslog(LOG_ERR, "%s:%d:%s: epoll_ctl: %s", __FILE__, __LINE__, __func__, strerror(errno));
		return -1;
	}
snippet epd
	// Remember to EPOLL_CTL_DEL *before* closing the file descriptor, see
	// https://idea.popcount.org/2017-03-20-epoll-is-fundamentally-broken-22/
	ret = epoll_ctl(
		${1:epoll_fd},
		EPOLL_CTL_DEL,
	    ${2:fd},
		NULL
	);
	if (-1 == ret) {
		syslog(LOG_ERR, "%s:%d:%s: epoll_ctl: %s", __FILE__, __LINE__, __func__, strerror(errno));
		return -1;
	}
snippet epm
	ret = epoll_ctl(
		${1:epoll_fd},
		EPOLL_CTL_MOD,
	    ${2:fd},
		&(struct epoll_event){
			.events = EPOLLIN | EPOLLERR | EPOLLHUP | EPOLLONESHOT,
			.data = event->data
		}
	);
	if (-1 == ret) {
		syslog(LOG_ERR, "%s:%d:%s: epoll_ctl: %s", __FILE__, __LINE__, __func__, strerror(errno));
		return -1;
	}${0}
snippet epw
	int ep_events_len = 0;
	struct epoll_event ep_events[EPOLL_NUM_EVENTS];
	for (ep_events_len = epoll_wait(${1:`vim_snippets#Filename('$1')`->epoll_fd}, ep_events, EPOLL_NUM_EVENTS, -1);
	     ep_events_len > 0;
	     ep_events_len = epoll_wait($1, ep_events, EPOLL_NUM_EVENTS, -1))
	{
		// (snippet: epev)
		ret = ${2:`vim_snippets#Filename('$1')`}_epoll_handle_events(${2:`vim_snippets#Filename('$1')`}, ep_events, ep_events_len);
		if (-1 == ret) {
			break;
		}
	}
	if (-1 == ep_events_len) {
		syslog(LOG_ERR, "%s:%d:%s: epoll_wait: %s", __FILE__, __LINE__, __func__, strerror(errno));
		exit(EXIT_FAILURE);
	}
	${0}
snippet epev
	static int `ProjectName()`_epoll_handle_events (
	    struct `ProjectName()`_s * `ProjectName()`,
		struct epoll_event epoll_events[EPOLL_NUM_EVENTS],
		int ep_events_len
	)
	{
		int ret = 0;
		for (int i = 0; i < ep_events_len; i++) {
			// (snippet: epdisp)
			ret = `ProjectName()`_epoll_event_dispatch(`ProjectName()`, &epoll_events[i]);
			if (0 != ret) {
				return ret;
			}
		}
	}
	${0}
snippet epdisp
	static int `ProjectName()`_epoll_event_dispatch (
		struct `ProjectName()`_s * `ProjectName()`,
		struct epoll_event * event
	)
	{
		if (event->data.fd == `ProjectName()`->fd)
			return `ProjectName()`_epoll_event_fd(`ProjectName()`, event);

		syslog(LOG_WARNING, "%s:%d:%s: No match on epoll event.", __FILE__, __LINE__, __func__);
		return 0;
	}
	${0}
# }}}

# vim: fdm=marker
