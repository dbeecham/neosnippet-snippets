# Control structures {{{
snippet     if
options     head
abbr        if () {}
    if (${1:#:condition}) {
        ${0:TARGET}
    }

# No head option in else/elseif so it can be expanded after "}"
snippet     else
abbr        else {}
    else {
        ${0:TARGET}
    }

snippet     elseif
abbr        else () {}
    else if (${1:#:condition}) {
        ${0:TARGET}
    }

snippet     ifelse
options     head
abbr        if () {} else {}
    if (${1:#:condition}) {
        ${2:TARGET}
    } else {
        ${3}
    }

snippet     for
options     head
abbr        for () {}
    for (${1:int} ${2:i} = ${3:0}; $2 < ${4}; $2++) {
        ${0:#:TARGET}
    }

# Counter based for's (don't ask for the type or count start)
snippet     fori
options     head
abbr        for (int x;...; x++) {}
    for (int ${1:i} = 0; $1 < ${2}; $1++) {
        ${0:#:TARGET}
    }

# For reverse counter
snippet     forri
options     head
abbr        for (int x; ...; x--) {}
    for (int ${1:i} = ${2}; $1 >= 0; $1--) {
        ${0:#:TARGET}
    }

snippet     while
options     head
abbr        while () {}
    while (${1:#:condition}) {
        ${0:TARGET}
    }

snippet     do_while
options     head
alias       do
    do {
        ${0:TARGET:code}
    } while (${1:#:condition});

snippet     switch
options     head
abbr        switch () {}
	switch (${1:#:var}) {
		case ${2:#:val}:
			${0:TARGET}
			break;
	}

snippet     case
options     head
abbr        case: break;
	case ${1}:
		${0}
		break;

# Ternary conditional operator
snippet conditional
    (${1:#:condition}) ? ${2:#:a} : ${3:#:b}

# }}}

# Definition bodies {{{
snippet     function
options     head
alias       func
abbr        func() {}
    ${1:void} ${2:#:func_name}(${3:void}) {
        ${0:TARGET}
    }

snippet     struct
options     head
abbr        struct {}
    struct ${1:`ProjectByFilename()`}${2:#:_something}${3:_s} {
        ${0:TARGET:int i;}}
    };

snippet     enum
options     head
abbr        enum {}
    enum ${1:#:name} {
        ${0:TARGET}
    };

# hard-tab is necessary; C indent doesn't support this.
snippet     main
options     head
	int main(int argc, char const* argv[])
	{
		${0:TARGET}
		return 0;
	}

snippet     helloworld
options     head
    #include <stdio.h>
    int main(int argc, char const* argv[])
    {
        puts("hello, world!");
        return 0;
    }

# }}}

# Preprocessing directives {{{
# #include <...>
snippet     inc
options     head
alias       #inc, #include
    #include <${1:stdio}.h>${0}

# #include "..."
snippet     inc2
options     head
alias       #inc2, #include2
    #include "${1}.h"${0}

snippet     ifdef
options     head
alias       #ifdef
abbr        #ifdef ... #endif
    #ifdef ${1:#:SYMBOL}
    ${0}
    #endif

snippet     ifndef
options     head
alias       #ifndef
abbr #ifndef ... #define ... #endif
    #ifndef $1
    #define ${1:#:SYMBOL}
    #endif${0}

snippet     def
options     head
alias       #def, #define
    #define

# Include-Guard
snippet     once
options     head
abbr        include-guard
    #ifndef ${1:#:SYMBOL}
        #define $1

        ${0:TARGET}
    #endif /* end of include guard */

# }}}

# Built-in function calls {{{
snippet printf
abbr    printf("...\n", ...);
    printf("${1}\n"${2});

snippet scanf
abbr    scanf("...", ...);
    scanf("${1}", ${2});

snippet fprintf
abbr    fprintf(..., "...\n", ...);
    fprintf(${1:stderr}, "${2}\n"${3});

snippet fopen
abbr fopen("...", "...");
	fopen("${1:PATH}", "${2:MODE}");
	${0:TARGET}
	fclose(${3:FD});

snippet fgets
abbr    fgets(row, length, file);
    fgets(${0:ROW}, ${1:LENGTH}, ${2:stdin});

snippet fscanf
abbr    fscanf(file, "...", ...);
    fscanf(${1:stdin}, "${2}", ${3});

snippet fwrite
abbr    fwrite(......, file)
    fwrite(${1:ARRAY}, sizeof(${2:TYPE}), ${3:N_MEMBERS}, ${4:FILE})

snippet fread
abbr    fread(......, file)
    fread(${1:ARRAY}, sizeof(${2:TYPE}), ${3:N_MEMBERS}, ${4:FILE})

snippet memcpy
abbr    memcpy(dest, src, nbytes)
    memcpy(${1:DEST}, ${2:SRC}, ${3:NBYTES})

snippet malloc
abbr    malloc(size)
	($2 *)malloc(${1:N_MEMBERS} * sizeof(${2:TYPE}));
	${0}
	free(${3:MEM});

snippet calloc
abbr    calloc(n, size)
	($2 *)calloc(${1:N_MEMBERS}, sizeof(${2:TYPE}));
	${0}
	free(${3:MEM});

snippet realloc
abbr    realloc(old, size)
	($3 *)realloc(${1:OLD}, ${2:N_MEMBERS} * sizeof(${3:TYPE}));
	${0}

snippet seed_rand
    srand(time(NULL));
# }}}

# Built-in operators and alias {{{
snippet typedef
    typedef ${1:#:base_type} ${2:#:custom_type};

snippet sizeof
alias   size
    sizeof(${0:TARGET})

snippet sizeof_array
alias   array_size
    (sizeof(${1:#:array}) / sizeof(*($1)))

snippet _Static_assert
alias   _static_assert
options head
    _Static_assert(${1:#:condition}, ${2:#:message});

snippet static_assert
options head
    static_assert(${1:#:condition}, ${2:#:message});

snippet _Generic
alias   generic, select
    _Generic(${1:#:expression}, ${2:#:association-list})

snippet va_list
options head
abbr    va_start(va_list, last_arg); ... ; va_end()
	va_list ${1:ap};
	va_start($1, ${2:LAST_ARG});
	${0}
	va_end($1);
# }}}

# Comments {{{
snippet comment
alias   /*
    /* ${1:#:comment} */
    ${0}

snippet     doxy
abbr        /** @brief ...
options     head
    /**
     * @brief    ${1:function description}
     *
     * @details  ${2:detailed description}
     *
     * @param    ${3:param}
     *
     * @return   ${4:return type}
     */

# }}}

# My own function definitions {{{
snippet     f
options     head
abbr        f() {}
	${1:int} ${2:`ProjectByFilename()`}${3:#:_something} (
        ${4:struct `ProjectByFilename()`_s * `ProjectByFilename()`}${5:#:, args...}
    )
	{
		int ret;

		${0:// something...}

		return 0;
	}

snippet     main
options     head
abbr        main() {}
    int main(int args, char * argv[]) {
        ${0}
    }

# }}}

# signals {{{
snippet     signal
options     head
abbr        // NOTE TO SELF: snippets available for signal
	// NOTE TO SELF: snippets available for signal:
	//   * sigblock    - set up sigprocmask with sensible stuff
	//   * sigw        - signal event handler loop
	//   * sigemptyset
	//   * sigaddset
	//   * sigprocmask
	// Remember to #include <signal.h> (snip 'isignal') and set feature test def
    ${1}

snippet sigblock
options head
abbr sigprocmask(SIG_BLOCK, ...)
	// block signals; use sigwaitinfo to synchronously receive these signals instead.
	ret = sigemptyset(${1}${2:`ProjectByFilename()`}${3:->sigset});
	if (-1 == ret) {
		syslog(LOG_ERR, "%s:%d:%s: sigemptyset: %s",
                __FILE__, __LINE__, __func__, strerror(errno));
		return -1;
	}

	ret = sigaddset($1$2$3, SIGPIPE);
	if (-1 == ret) {
		syslog(LOG_ERR, "%s:%d:%s: sigaddset: %s",
                __FILE__, __LINE__, __func__, strerror(errno));
		return -1;
	}

	ret = sigaddset($1$2$3, SIGTERM);
	if (-1 == ret) {
		syslog(LOG_ERR, "%s:%d:%s: sigaddset: %s",
                __FILE__, __LINE__, __func__, strerror(errno));
		return -1;
	}

	ret = sigaddset($1$2$3, SIGINT);
	if (-1 == ret) {
		syslog(LOG_ERR, "%s:%d:%s: sigaddset: %s",
                __FILE__, __LINE__, __func__, strerror(errno));
		return -1;
	}

	ret = sigprocmask(
			/* how = */ SIG_BLOCK,
			/* set = */ $1$2$3,
			/* old = */ NULL
	);
	if (-1 == ret) {
		syslog(LOG_ERR, "%s:%d:%s: sigprocmask: %s",
                __FILE__, __LINE__, __func__, strerror(errno));
		return -1;
	}
    ${0}

snippet sigd
options head
abbr sigwait_dispatch(...)
    int ${1:`ProjectByFilename()`}_sigwait_dispatch (
        struct ${2:`ProjectByFilename()`}_s * ${3:`ProjectByFilename()`},
        siginfo_t * siginfo
    )
    {
       ${0:TARGET} 
    }

snippet sigw
options head
abbr sigwaitinfo(...)
	siginfo_t siginfo;
	int signal_number = 0;
	for (signal_number = sigwaitinfo(${1}${2:`ProjectByFilename()`}${3:->sigset}, &siginfo);
	     signal_number != -1;
	     signal_number = sigwaitinfo($1$2$3, &siginfo))
	{
		syslog(LOG_INFO, "%s:%d:%s: signal %d cought...",
                __FILE__, __LINE__, __func__, signal_number);

        ret = `ProjectByFilename()`_sigwait_dispatch($1$2, &siginfo);
        if (ret < 0) {
            syslog(LOG_WARNING, "%s:%d:%s: `ProjectByFilename()`_sigwait_dispatch returned %d",
                    __FILE__, __LINE__, __func__, ret);
            return -1;
        }
		// dispatch on siginfo
		// pthread_cancel -> pthread_join?
		// write to stderr, out?
        ${0:TARGET}
	}
	if (-1 == signal_number) {
		syslog(LOG_ERR, "%s:%d:%s: sigwaitinfo: %s",
                __FILE__, __LINE__, __func__, strerror(errno));
		return -1;
	}

# }}}

# common stuff {{{
snippet c
options head
abbr if (ret < 0) { ... }
    if (ret < 0) {
        ${0}
    }
# }}}

# syslog {{{
snippet     err
options     head
abbr        syslog(LOG_ERR, "... returned %d")
	syslog(LOG_ERR, "%s:%d:%s: ${1:func} returned %d",
	       __FILE__, __LINE__, __func__, ${2:ret});

snippet     warn
options     head
abbr        syslog(LOG_WARN, "... returned %d")
	syslog(LOG_WARN, "%s:%d:%s: ${1:func} returned %d",
	       __FILE__, __LINE__, __func__, ${2:ret});

snippet     debug
options     head
abbr        syslog(LOG_DEBUG, "...")
	syslog(LOG_DEBUG, "%s:%d:%s: ${1:...}",
	       __FILE__, __LINE__, __func__);

snippet     info
options     head
abbr        syslog(LOG_INFO, "...")
	syslog(LOG_INFO, "%s:%d:%s: ${1:...}",
	       __FILE__, __LINE__, __func__);

snippet     hi
options     head
abbr        syslog(LOG_DEBUG, "hi! ...")
	syslog(LOG_DEBUG, "%s:%d:%s: hi! ${1:arg=%p}",
	       __FILE__, __LINE__, __func__, ${2:arg});

# }}}

# exit {{{
snippet     exit
options     head
abbr        exit(EXIT_FAILURE)
	exit(EXIT_FAILURE);

snippet     quit
options     head
abbr        exit(EXIT_SUCCESS)
	exit(EXIT_SUCCESS);

# }}}

# vim: fdm=marker
